#!/usr/bin/env ruby

require 'optparse'

class Output
  def self.for(format)
    case format
    when :json
      JsonOutput
    when :console
      ConsoleOutput
    else
      ConsoleOutput
    end
  end
end

class JsonOutput
  def self.output(options, header, ascii)
    require 'json'
    puts ascii.to_a.to_json
  end
end

class ConsoleOutput
  def self.output(options, header, ascii)
    header_string = header.reduce("") do |result, element|
      result << element.ljust(element.length + 3)
    end
    puts header_string.strip if options[:header]
    ascii.each do |row|
      row_string = ""
      options[:representations].each_with_index do |representation, index|
        if index == options[:representations].length - 1
          row_string << row[representation]
        else
          row_string << row[representation].ljust(header[index].length + 3)
        end
      end
      puts row_string
    end
  end
end

class PrintableAscii
  VERSION = [2, 0, 0]

  def main
    options = Configuration.parse_options(ARGV)
    header = build_header(options)
    ascii = build_ascii(options)
    Output.for(options[:format]).output(options, header, ascii)
  end

  def build_header(options)
    options[:representations].map do |choice|
      choice.to_s.upcase
    end
  end

  def build_ascii(options)
    ascii_list = []
    options[:ranges].each do |range|
      range[0].upto(range[1]) do |n|
        result = {}
        options[:representations].each do |choice|
          result[choice] = format(n, choice)
        end
        ascii_list << result
      end
    end
    ascii_list = lazy_random_enumerator(ascii_list, options[:random]) if options[:random]
    ascii_list
  end

  def lazy_random_enumerator(list, count)
    Enumerator.new do |e|
      loop {
        e << list.sample
      }
    end.take(count).lazy
  end

  def format(number, representation)
    case representation
    when :character
      number.chr
    when :binary
      sprintf("%b", number)
    when :octal
      sprintf("%o", number)
    when :decimal
      sprintf("%d", number)
    when :hexadecimal
      sprintf("%x", number)
    else
      "#{representation} is an unknown format"
    end
  end
end

class Configuration
  def self.restrict_to_printable_ascii(n)
    if n < 32
      raise OptionParser::InvalidArgument.new("#{n} is not a valid value")
    end

    if n > 126
      raise OptionParser::InvalidArgument.new("#{n} is not a valid value")
    end

    return n
  end

  def self.parse_start_end(given)
    if given.length == 1 && given.ascii_only?
      given.ord
    else
      begin
        given = Integer(given)
      rescue ArgumentError
        raise OptionParser::InvalidArgument.new("#{given} is not a valid value")
      end
      restrict_to_printable_ascii(given)
    end
  end

  def self.parse_options(argv)
    options = {
      representations: [:character],
      format: :console,
      ranges: [],
    }

    parser = OptionParser.new do |opts|
      opts.banner = "Usage: #{$PROGRAM_NAME} [options]"

      opts.on_tail("-h", "--help", "Show this message") do |v|
        puts opts
        exit
      end

      opts.on_tail("--version", "Show version") do
        puts PrintableAscii::VERSION.join('.')
        exit
      end

      opts.on("-d", "--decimal", "Output decimal representation") do
        options[:representations] << :decimal
      end

      opts.on("-b", "--binary", "Output binary representation") do
        options[:representations] << :binary
      end

      opts.on("-x", "--hexadecimal", "Output hexadecimal representation") do
        options[:representations] << :hexadecimal
      end

      opts.on("-o", "--octal", "Output octal representation") do
        options[:representations] << :octal
      end

      opts.on("--header", "Include the header in output") do
        options[:header] = true
      end

      opts.on("--no-header", "Omit the header from output") do
        options[:header] = false
      end

      opts.on("--json", "JSON output") do
        options[:format] = :json
      end

      opts.on("-s", "--start-at NUMBER|ASCII", "Start ASCII list at base10 NUMBER (32-126) or ASCII character") do |given|
        start_at = parse_start_end(given)
        options[:start_at] = start_at
      end

      opts.on("-e", "--end-at NUMBER|ASCII", "End ASCII list at base10 NUMBER (32-126) or ASCII character") do |given|
        end_at = parse_start_end(given)
        options[:end_at] = end_at
      end

      opts.on("--random NUMBER", Integer, "Output NUMBER of random printable ASCII characters") do |n|
        options[:random] = n
      end

      opts.on("--range START-END", "Restrict the ASCII list to start-end. Can be supplied multiple times. Supersedes --start-at and --end-at arguments.") do |r|
        (start, finish) = r.split("-")
        start = parse_start_end(start)
        finish = parse_start_end(finish)
        if start > finish
          $stderr.puts "#{r} parses as (#{start}-#{finish}) and outputs no characters because the start is greater than the end"
        end
        options[:ranges] << [start, finish]
      rescue NoMethodError
        raise OptionParser::InvalidArgument.new(r)
      end
    end

    begin
      parser.parse!(argv)
    rescue OptionParser::InvalidArgument => e
      $stderr.puts e
      $stderr.puts parser
      exit 1
    rescue OptionParser::InvalidOption => e
      $stderr.puts e
      $stderr.puts parser
      exit 1
    rescue ArgumentError => e
      $stderr.puts e
      $stderr.puts parser
      exit 1
    end

    massage_options(options)
  end

  def self.massage_options(options)
    if options[:representations] != [:character] && options[:header].nil?
      options[:header] = true
    end

    if options[:ranges].length > 0
      $stderr.puts "--start-at is ignored if --range is given" if ! options[:start_at].nil?
      $stderr.puts "--end-at is ignored if --range is given" if ! options[:end_at].nil?
    end

    if options[:ranges].length == 0
      start_at = options[:start_at] ? options[:start_at] : 32
      end_at = options[:end_at] ? options[:end_at] : 126
      options[:ranges] << [start_at, end_at]
    end

    options
  end
end

if $0 == __FILE__
  PrintableAscii.new.main
end
