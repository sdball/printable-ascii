#!/usr/bin/env ruby

require 'optparse'

class Output
  def self.for(format)
    case format
    when :json
      JsonOutput
    when :console
      ConsoleOutput
    else
      ConsoleOutput
    end
  end
end

class JsonOutput
  def self.output(options, header, ascii)
    require 'json'
    puts ascii.to_a.to_json
  end
end

class ConsoleOutput
  def self.output(options, header, ascii)
    header_string = header.reduce("") do |result, element|
      result << element.ljust(element.length + 3)
    end
    puts header_string.strip if options[:header]
    ascii.each do |row|
      row_string = ""
      options[:representations].each_with_index do |representation, index|
        if index == options[:representations].length - 1
          row_string << row[representation]
        else
          row_string << row[representation].ljust(header[index].length + 3)
        end
      end
      puts row_string
    end
  end
end

class PrintableAscii
  VERSION = [1, 2, 0]

  def main
    options = Configuration.parse_options(ARGV)
    if options[:representations] != [:character] && options[:header].nil?
      options[:header] = true
    end
    header = build_header(options)
    ascii = build_ascii(options)
    ascii = lazy_random_enumerator(ascii, options[:random]) if options[:random]
    Output.for(options[:format]).output(options, header, ascii)
  end

  def build_header(options)
    options[:representations].map do |choice|
      choice.to_s.upcase
    end
  end

  def build_ascii(options)
    options[:start_at].upto(options[:end_at]).map do |n|
      result = {}
      options[:representations].map do |choice|
        result[choice] = format(n, choice)
      end
      result
    end
  end

  def lazy_random_enumerator(list, count)
    Enumerator.new do |e|
      loop {
        e << list.sample
      }
    end.take(count).lazy
  end

  def format(number, representation)
    case representation
    when :character
      number.chr
    when :binary
      sprintf("%b", number)
    when :octal
      sprintf("%o", number)
    when :decimal
      sprintf("%d", number)
    when :hexadecimal
      sprintf("%x", number)
    else
      "#{representation} is an unknown format"
    end
  end
end

class Configuration
  def self.restrict_to_printable_ascii(n, context="")
    context << " " if context != ""
    if n < 32
      $stderr.puts "#{context}cannot be less than 32: changing to 32"
      return 32
    end

    if n > 126
      $stderr.puts "#{context}cannot be greater than 126: changing to 126"
      return 126
    end

    return n
  end

  def self.parse_options(argv)
    options = {
      representations: [:character],
      format: :console,
      start_at: 32,
      end_at: 126,
    }

    parser = OptionParser.new do |opts|
      opts.banner = "Usage: #{$PROGRAM_NAME} [options]"

      opts.on_tail("-h", "--help", "Show this message") do |v|
        puts opts
        exit
      end

      opts.on_tail("--version", "Show version") do
        puts PrintableAscii::VERSION.join('.')
        exit
      end

      opts.on("-d", "--decimal", "Output decimal representation") do
        options[:representations] << :decimal
      end

      opts.on("-b", "--binary", "Output binary representation") do
        options[:representations] << :binary
      end

      opts.on("-x", "--hexadecimal", "Output hexadecimal representation") do
        options[:representations] << :hexadecimal
      end

      opts.on("-o", "--octal", "Output octal representation") do
        options[:representations] << :octal
      end

      opts.on("--header", "Include the header in output") do
        options[:header] = true
      end

      opts.on("--no-header", "Omit the header from output") do
        options[:header] = false
      end

      opts.on("--json", "JSON output") do
        options[:format] = :json
      end

      opts.on("-s", "--start-at NUMBER|ASCII", "Start ASCII list at base10 NUMBER (32-126) or ASCII character") do |given|
        if given.length == 1 && given.ascii_only?
          start_at = given.ord
        else
          start_at = restrict_to_printable_ascii(given.to_i, "start")
        end
        options[:start_at] = start_at
      end

      opts.on("-e", "--end-at NUMBER|ASCII", "End ASCII list at base10 NUMBER (32-126) or ASCII character") do |given|
        if given.length == 1 && given.ascii_only?
          end_at = given.ord
        else
          end_at = restrict_to_printable_ascii(given.to_i, "end")
        end
        options[:end_at] = end_at
      end

      opts.on("--random NUMBER", Integer, "Output NUMBER of random printable ASCII characters") do |n|
        options[:random] = n
      end
    end

    begin
      parser.parse!(argv)
    rescue OptionParser::InvalidArgument => e
      $stderr.puts e
      $stderr.puts parser
      exit 1
    rescue OptionParser::InvalidOption => e
      $stderr.puts e
      $stderr.puts parser
      exit 1
    end

    options
  end
end

if $0 == __FILE__
  PrintableAscii.new.main
end
