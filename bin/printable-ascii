#!/usr/bin/env ruby

require 'optparse'

class Output
  def self.for(format)
    case format
    when :json
      JsonOutput
    when :console
      ConsoleOutput
    else
      ConsoleOutput
    end
  end
end

class JsonOutput
  def self.output(options, header, ascii)
    require 'json'
    puts ascii.to_a.to_json
  end
end

class ConsoleOutput
  def self.output(options, header, ascii)
    header_string = header.reduce("") do |result, element|
      result << element.ljust(spacing(element))
    end
    puts header_string.strip if options[:header]
    ascii.each do |row|
      row_string = ""
      options[:representations].each_with_index do |representation, index|
        if index == options[:representations].length - 1
          row_string << row[representation]
        else
          row_string << row[representation].ljust(spacing(representation))
        end
      end
      puts row_string
    end
  end

  def self.spacing(element)
    case element.to_s.downcase
    when "name"
      22 + 3
    when "info_url"
      29 + 3
    else
      element.length + 3
    end
  end
end

class PrintableAscii
  VERSION = [2, 2, 0]

  def main
    options = Configuration.parse_options(ARGV)
    header = build_header(options)
    ascii = build_ascii(options)
    Output.for(options[:format]).output(options, header, ascii)
  end

  def build_header(options)
    options[:representations].map do |choice|
      choice.to_s.upcase
    end
  end

  def build_ascii(options)
    ascii_list = []
    options[:ranges].each do |range|
      range[0].upto(range[1]) do |n|
        result = {}
        options[:representations].each do |choice|
          result[choice] = format(n, choice)
        end
        ascii_list << result
      end
    end
    ascii_list = lazy_random_enumerator(ascii_list, options[:random]) if options[:random]
    ascii_list
  end

  def lazy_random_enumerator(list, count)
    Enumerator.new do |e|
      loop {
        e << list.sample
      }
    end.take(count).lazy
  end

  def format(number, representation)
    case representation
    when :character
      number.chr
    when :binary
      sprintf("%b", number)
    when :octal
      sprintf("%o", number)
    when :decimal
      sprintf("%d", number)
    when :hexadecimal
      sprintf("%x", number)
    when :name
      CHARACTER_NAME.fetch(number, number)
    when :info_url
      "https://codepoints.net/U+00#{sprintf("%x", number)}"
    else
      "#{representation} is an unknown format"
    end
  end
end

class Configuration
  def self.restrict_to_printable_ascii(n)
    if n < 32
      raise OptionParser::InvalidArgument.new("#{n} is not a valid value")
    end

    if n > 126
      raise OptionParser::InvalidArgument.new("#{n} is not a valid value")
    end

    return n
  end

  def self.parse_start_end(given)
    if given.length == 1 && given.ascii_only?
      given.ord
    else
      begin
        given = Integer(given)
      rescue ArgumentError
        raise OptionParser::InvalidArgument.new("#{given} is not a valid value")
      end
      restrict_to_printable_ascii(given)
    end
  end

  def self.parse_options(argv)
    options = {
      representations: [:character],
      format: :console,
      ranges: [],
    }

    parser = OptionParser.new do |opts|
      opts.banner = "Usage: #{$PROGRAM_NAME} [options]"

      opts.on_tail("-h", "--help", "Show this message") do |v|
        puts opts
        exit
      end

      opts.on_tail("--version", "Show version") do
        puts PrintableAscii::VERSION.join('.')
        exit
      end

      opts.on("-d", "--decimal", "Output decimal representation") do
        options[:representations] << :decimal
      end

      opts.on("-b", "--binary", "Output binary representation") do
        options[:representations] << :binary
      end

      opts.on("-x", "--hexadecimal", "Output hexadecimal representation") do
        options[:representations] << :hexadecimal
      end

      opts.on("-o", "--octal", "Output octal representation") do
        options[:representations] << :octal
      end

      opts.on("--character-name", "Output character name (same as --name)") do
        options[:representations] << :name
      end

      opts.on("--name", "Output character name (same as --character-name)") do
        options[:representations] << :name
      end

      opts.on("--info-url", "Include a URL with further character details") do
        options[:representations] << :info_url
      end

      opts.on("--header", "Include the header in output") do
        options[:header] = true
      end

      opts.on("--no-header", "Omit the header from output") do
        options[:header] = false
      end

      opts.on("--json", "JSON output") do
        options[:format] = :json
      end

      opts.on("-s", "--start-at NUMBER|ASCII", "Start ASCII list at base10 NUMBER (32-126) or ASCII character") do |given|
        start_at = parse_start_end(given)
        options[:start_at] = start_at
      end

      opts.on("-e", "--end-at NUMBER|ASCII", "End ASCII list at base10 NUMBER (32-126) or ASCII character") do |given|
        end_at = parse_start_end(given)
        options[:end_at] = end_at
      end

      opts.on("--random NUMBER", Integer, "Output NUMBER of random printable ASCII characters") do |n|
        options[:random] = n
      end

      opts.on("--range START-END", "Restrict the ASCII list to start-end. Can be supplied multiple times.") do |r|
        if r.start_with? "-"
          start = "-"
          finish = r.gsub(/^-+/, "")
        elsif r.end_with? "-"
          finish = "-"
          start = r.gsub(/-+$/, "")
        else
          (start, finish) = r.split("-")
        end

        start = parse_start_end(start)
        finish = parse_start_end(finish)

        if start > finish
          $stderr.puts "#{r} parses as (#{start}-#{finish}) and outputs no characters because the start is greater than the end"
        end

        options[:ranges] << [start, finish]
      rescue NoMethodError
        raise OptionParser::InvalidArgument.new(r)
      end

      opts.on("--punctuation", "Show punctuation characters. Added as a set of ranges") do
        options[:ranges] << [32, 47]
        options[:ranges] << [58, 64]
        options[:ranges] << [91, 96]
        options[:ranges] << [123, 126]
      end

      opts.on("--alphabetic", "Show alphabetic characters. Added as a set of ranges") do
        options[:ranges] << [65, 90]
        options[:ranges] << [97, 122]
      end

      opts.on("--letters", "Show alphabetic characters. Added as a set of ranges") do
        options[:ranges] << [65, 90]
        options[:ranges] << [97, 122]
      end

      opts.on("--uppercase", "Show uppercase alphabetic characters. Added as a range") do
        options[:ranges] << [65, 90]
      end

      opts.on("--lowercase", "Show lowercase alphabetic characters. Added as a range") do
        options[:ranges] << [97, 122]
      end

      opts.on("--numeric", "Show number characters. Added as a range (same as --digits)") do
        options[:ranges] << [48, 57]
      end

      opts.on("--digits", "Show number characters. Added as a range (same as --numeric)") do
        options[:ranges] << [48, 57]
      end

      opts.on("--space", "Show the space character. Fun fact: <tab> is not in the set of printable ASCII") do
        options[:ranges] << [32, 32]
      end

      opts.on("--binary-digits", "Show the binary digits. Added as a range") do
        options[:ranges] << [48, 49]
      end

      opts.on("--octal-digits", "Show the octal digits. Added as a range") do
        options[:ranges] << [48, 55]
      end

      opts.on("--hex-digits", "Show the hexadecimal digits. Added as a range") do
        options[:ranges] << [48, 57]
        options[:ranges] << [65, 70]
      end
    end

    begin
      parser.parse!(argv)
    rescue OptionParser::InvalidArgument => e
      $stderr.puts e
      $stderr.puts parser
      exit 1
    rescue OptionParser::InvalidOption => e
      $stderr.puts e
      $stderr.puts parser
      exit 1
    rescue ArgumentError => e
      $stderr.puts e
      $stderr.puts parser
      exit 1
    rescue OptionParser::AmbiguousOption => e
      $stderr.puts e
      $stderr.puts parser
      exit 1
    end

    massage_options(options)
  end

  def self.massage_options(options)
    if options[:representations] != [:character] && options[:header].nil?
      options[:header] = true
    end

    if options[:ranges].length > 0
      $stderr.puts "--start-at is ignored if --range is given" if ! options[:start_at].nil?
      $stderr.puts "--end-at is ignored if --range is given" if ! options[:end_at].nil?
    end

    if options[:ranges].length == 0
      start_at = options[:start_at] ? options[:start_at] : 32
      end_at = options[:end_at] ? options[:end_at] : 126
      options[:ranges] << [start_at, end_at]
    end

    options
  end
end

CHARACTER_NAME = {
  32 => "SPACE",
  33 => "EXCLAMATION MARK",
  34 => "QUOTATION MARK",
  35 => "NUMBER SIGN",
  36 => "DOLLAR SIGN",
  37 => "PERCENT SIGN",
  38 => "AMPERSAND",
  39 => "APOSTROPHE",
  40 => "LEFT PARENTHESIS",
  41 => "RIGHT PARENTHESIS",
  42 => "ASTERISK",
  43 => "PLUS SIGN",
  44 => "COMMA",
  45 => "HYPHEN-MINUS",
  46 => "FULL STOP",
  47 => "SOLIDUS",
  48 => "DIGIT ZERO",
  49 => "DIGIT ONE",
  50 => "DIGIT TWO",
  51 => "DIGIT THREE",
  52 => "DIGIT FOUR",
  53 => "DIGIT FIVE",
  54 => "DIGIT SIX",
  55 => "DIGIT SEVEN",
  56 => "DIGIT EIGHT",
  57 => "DIGIT NINE",
  58 => "COLON",
  59 => "SEMICOLON",
  60 => "LESS-THAN SIGN",
  61 => "EQUALS SIGN",
  62 => "GREATER-THAN SIGN",
  63 => "QUESTION MARK",
  64 => "COMMERCIAL AT",
  65 => "LATIN CAPITAL LETTER A",
  66 => "LATIN CAPITAL LETTER B",
  67 => "LATIN CAPITAL LETTER C",
  68 => "LATIN CAPITAL LETTER D",
  69 => "LATIN CAPITAL LETTER E",
  70 => "LATIN CAPITAL LETTER F",
  71 => "LATIN CAPITAL LETTER G",
  72 => "LATIN CAPITAL LETTER H",
  73 => "LATIN CAPITAL LETTER I",
  74 => "LATIN CAPITAL LETTER J",
  75 => "LATIN CAPITAL LETTER K",
  76 => "LATIN CAPITAL LETTER L",
  77 => "LATIN CAPITAL LETTER M",
  78 => "LATIN CAPITAL LETTER N",
  79 => "LATIN CAPITAL LETTER O",
  80 => "LATIN CAPITAL LETTER P",
  81 => "LATIN CAPITAL LETTER Q",
  82 => "LATIN CAPITAL LETTER R",
  83 => "LATIN CAPITAL LETTER S",
  84 => "LATIN CAPITAL LETTER T",
  85 => "LATIN CAPITAL LETTER U",
  86 => "LATIN CAPITAL LETTER V",
  87 => "LATIN CAPITAL LETTER W",
  88 => "LATIN CAPITAL LETTER X",
  89 => "LATIN CAPITAL LETTER Y",
  90 => "LATIN CAPITAL LETTER Z",
  91 => "LEFT SQUARE BRACKET",
  92 => "REVERSE SOLIDUS",
  93 => "RIGHT SQUARE BRACKET",
  94 => "CIRCUMFLEX ACCENT",
  95 => "LOW LINE",
  96 => "GRAVE ACCENT",
  97 => "LATIN SMALL LETTER A",
  98 => "LATIN SMALL LETTER B",
  99 => "LATIN SMALL LETTER C",
  100 => "LATIN SMALL LETTER D",
  101 => "LATIN SMALL LETTER E",
  102 => "LATIN SMALL LETTER F",
  103 => "LATIN SMALL LETTER G",
  104 => "LATIN SMALL LETTER H",
  105 => "LATIN SMALL LETTER I",
  106 => "LATIN SMALL LETTER J",
  107 => "LATIN SMALL LETTER K",
  108 => "LATIN SMALL LETTER L",
  109 => "LATIN SMALL LETTER M",
  110 => "LATIN SMALL LETTER N",
  111 => "LATIN SMALL LETTER O",
  112 => "LATIN SMALL LETTER P",
  113 => "LATIN SMALL LETTER Q",
  114 => "LATIN SMALL LETTER R",
  115 => "LATIN SMALL LETTER S",
  116 => "LATIN SMALL LETTER T",
  117 => "LATIN SMALL LETTER U",
  118 => "LATIN SMALL LETTER V",
  119 => "LATIN SMALL LETTER W",
  120 => "LATIN SMALL LETTER X",
  121 => "LATIN SMALL LETTER Y",
  122 => "LATIN SMALL LETTER Z",
  123 => "LEFT CURLY BRACKET",
  124 => "VERTICAL LINE",
  125 => "RIGHT CURLY BRACKET",
  126 => "TILDE",
}

if $0 == __FILE__
  PrintableAscii.new.main
end
